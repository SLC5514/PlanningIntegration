<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="./main.css" />
  </head>
  <body>
    <div id="container"></div>
    <div id="info">
      <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
      - webgl ocean
    </div>
  </body>

  <!-- This is the 'compute shader' for the water heightmap: -->
  <script id="heightmapFragmentShader" type="x-shader/x-fragment">

    #include <common>

    uniform vec2 mousePos;
    uniform float mouseSize;
    uniform float viscosityConstant;
    uniform float heightCompensation;

    void main()	{

      vec2 cellSize = 1.0 / resolution.xy;

      vec2 uv = gl_FragCoord.xy * cellSize;

      // heightmapValue.x == height from previous frame
      // heightmapValue.y == height from penultimate frame
      // heightmapValue.z, heightmapValue.w not used
      vec4 heightmapValue = texture2D( heightmap, uv );

      // Get neighbours
      vec4 north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) );
      vec4 south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) );
      vec4 east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) );
      vec4 west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) );

      // https://web.archive.org/web/20080618181901/http://freespace.virgin.net/hugo.elias/graphics/x_water.htm

      float newHeight = ( ( north.x + south.x + east.x + west.x ) * 0.5 - heightmapValue.y ) * viscosityConstant;

      // Mouse influence
      float mousePhase = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( mousePos.x, - mousePos.y ) ) * PI / mouseSize, 0.0, PI );
      newHeight += ( cos( mousePhase ) + 1.0 ) * 0.28;

      heightmapValue.y = heightmapValue.x;
      heightmapValue.x = newHeight;

      gl_FragColor = heightmapValue;

    }
  </script>

  <!-- This is just a smoothing 'compute shader' for using manually: -->
  <script id="smoothFragmentShader" type="x-shader/x-fragment">

    uniform sampler2D smoothTexture;

    void main()	{

      vec2 cellSize = 1.0 / resolution.xy;

      vec2 uv = gl_FragCoord.xy * cellSize;

      // Computes the mean of texel and 4 neighbours
      vec4 textureValue = texture2D( smoothTexture, uv );
      textureValue += texture2D( smoothTexture, uv + vec2( 0.0, cellSize.y ) );
      textureValue += texture2D( smoothTexture, uv + vec2( 0.0, - cellSize.y ) );
      textureValue += texture2D( smoothTexture, uv + vec2( cellSize.x, 0.0 ) );
      textureValue += texture2D( smoothTexture, uv + vec2( - cellSize.x, 0.0 ) );

      textureValue /= 5.0;

      gl_FragColor = textureValue;

    }
  </script>

  <!-- This is a 'compute shader' to read the current level and normal of water at a point -->
  <!-- It is used with a variable of size 1x1 -->
  <script id="readWaterLevelFragmentShader" type="x-shader/x-fragment">

    uniform vec2 point1;

    uniform sampler2D levelTexture;

    // Integer to float conversion from https://stackoverflow.com/questions/17981163/webgl-read-pixels-from-floating-point-render-target

    float shift_right( float v, float amt ) {

      v = floor( v ) + 0.5;
      return floor( v / exp2( amt ) );

    }

    float shift_left( float v, float amt ) {

      return floor( v * exp2( amt ) + 0.5 );

    }

    float mask_last( float v, float bits ) {

      return mod( v, shift_left( 1.0, bits ) );

    }

    float extract_bits( float num, float from, float to ) {

      from = floor( from + 0.5 ); to = floor( to + 0.5 );
      return mask_last( shift_right( num, from ), to - from );

    }

    vec4 encode_float( float val ) {
      if ( val == 0.0 ) return vec4( 0, 0, 0, 0 );
      float sign = val > 0.0 ? 0.0 : 1.0;
      val = abs( val );
      float exponent = floor( log2( val ) );
      float biased_exponent = exponent + 127.0;
      float fraction = ( ( val / exp2( exponent ) ) - 1.0 ) * 8388608.0;
      float t = biased_exponent / 2.0;
      float last_bit_of_biased_exponent = fract( t ) * 2.0;
      float remaining_bits_of_biased_exponent = floor( t );
      float byte4 = extract_bits( fraction, 0.0, 8.0 ) / 255.0;
      float byte3 = extract_bits( fraction, 8.0, 16.0 ) / 255.0;
      float byte2 = ( last_bit_of_biased_exponent * 128.0 + extract_bits( fraction, 16.0, 23.0 ) ) / 255.0;
      float byte1 = ( sign * 128.0 + remaining_bits_of_biased_exponent ) / 255.0;
      return vec4( byte4, byte3, byte2, byte1 );
    }

    void main()	{

      vec2 cellSize = 1.0 / resolution.xy;

      float waterLevel = texture2D( levelTexture, point1 ).x;

      vec2 normal = vec2(
        ( texture2D( levelTexture, point1 + vec2( - cellSize.x, 0 ) ).x - texture2D( levelTexture, point1 + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
        ( texture2D( levelTexture, point1 + vec2( 0, - cellSize.y ) ).x - texture2D( levelTexture, point1 + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS );

      if ( gl_FragCoord.x < 1.5 ) {

        gl_FragColor = encode_float( waterLevel );

      } else if ( gl_FragCoord.x < 2.5 ) {

        gl_FragColor = encode_float( normal.x );

      } else if ( gl_FragCoord.x < 3.5 ) {

        gl_FragColor = encode_float( normal.y );

      } else {

        gl_FragColor = encode_float( 0.0 );

      }

    }
  </script>

  <!-- This is the water visualization shader, copied from the THREE.MeshPhongMaterial and modified: -->
  <script id="waterVertexShader" type="x-shader/x-vertex">

    uniform sampler2D heightmap;

    #define PHONG

    varying vec3 vViewPosition;

    #ifndef FLAT_SHADED

      varying vec3 vNormal;

    #endif

    #include <common>
    #include <uv_pars_vertex>
    #include <uv2_pars_vertex>
    #include <displacementmap_pars_vertex>
    #include <envmap_pars_vertex>
    #include <color_pars_vertex>
    #include <morphtarget_pars_vertex>
    #include <skinning_pars_vertex>
    #include <shadowmap_pars_vertex>
    #include <logdepthbuf_pars_vertex>
    #include <clipping_planes_pars_vertex>

    void main() {

      vec2 cellSize = vec2( 1.0 / WIDTH, 1.0 / WIDTH );

      #include <uv_vertex>
      #include <uv2_vertex>
      #include <color_vertex>

      // # include <beginnormal_vertex>
      // Compute normal from heightmap
      vec3 objectNormal = vec3(
        ( texture2D( heightmap, uv + vec2( - cellSize.x, 0 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,
        ( texture2D( heightmap, uv + vec2( 0, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS,
        1.0 );
      //<beginnormal_vertex>

      #include <morphnormal_vertex>
      #include <skinbase_vertex>
      #include <skinnormal_vertex>
      #include <defaultnormal_vertex>

    #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

      vNormal = normalize( transformedNormal );

    #endif

      //# include <begin_vertex>
      float heightValue = texture2D( heightmap, uv ).x;
      vec3 transformed = vec3( position.x, position.y, heightValue );
      //<begin_vertex>

      #include <morphtarget_vertex>
      #include <skinning_vertex>
      #include <displacementmap_vertex>
      #include <project_vertex>
      #include <logdepthbuf_vertex>
      #include <clipping_planes_vertex>

      vViewPosition = - mvPosition.xyz;

      #include <worldpos_vertex>
      #include <envmap_vertex>
      #include <shadowmap_vertex>

    }
  </script>

  <script type="x-shader/x-fragment" id="fragmentShader">
    //获取纹理
    uniform sampler2D texture1;
    //纹理坐标
    varying vec2 vUv;

    void main(void){
    //texture2D()获取纹素
        gl_FragColor = texture2D(texture1, vUv);
    }
  </script>

  <script id="vertexShader" type="x-shader/x-vertex">
    varying vec2 vUv;
    void main(){
      vUv = uv;
      vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
      //projectionMatrix * mvPosition; 最终得到MVP矩阵
      gl_Position = projectionMatrix * mvPosition;
    }
  </script>

  <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script src="./three.min.js"></script>
  <script src="./stats.min.js"></script>
  <script src="./dat.gui.min.js"></script>
  <script src="./OrbitControls.js"></script>
  <script src="./Water.js"></script>
  <script src="./Sky.js"></script>
  <script src="./GPUComputationRenderer.js"></script>
  <script src="./SimplexNoise.js"></script>
  <!-- <script>
    let container, stats;
    let camera, scene, renderer;
    let controls, water, sun, mesh;

    init();
    animate();

    function init() {
      container = document.getElementById("container");

      //

      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      container.appendChild(renderer.domElement);

      //

      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(
        55,
        window.innerWidth / window.innerHeight,
        1,
        20000
      );
      camera.position.set(30, 30, 100);

      //

      sun = new THREE.Vector3();

      // Water

      const waterGeometry = new THREE.PlaneGeometry(10000, 10000);

      water = new THREE.Water(waterGeometry, {
        textureWidth: 512,
        textureHeight: 512,
        waterNormals: new THREE.TextureLoader().load(
          "./waternormals.jpg",
          function (texture) {
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
          }
        ),
        sunDirection: new THREE.Vector3(),
        sunColor: 0xffffff,
        waterColor: 0x001e0f,
        distortionScale: 3.7,
        fog: scene.fog !== undefined,
      });

      water.rotation.x = -Math.PI / 2;

      scene.add(water);

      // Skybox

      const sky = new THREE.Sky();
      sky.scale.setScalar(10000);
      scene.add(sky);

      const skyUniforms = sky.material.uniforms;

      skyUniforms["turbidity"].value = 10;
      skyUniforms["rayleigh"].value = 2;
      skyUniforms["mieCoefficient"].value = 0.005;
      skyUniforms["mieDirectionalG"].value = 0.8;

      const parameters = {
        elevation: 2,
        azimuth: 180,
      };

      const pmremGenerator = new THREE.PMREMGenerator(renderer);

      function updateSun() {
        const phi = THREE.MathUtils.degToRad(90 - parameters.elevation);
        const theta = THREE.MathUtils.degToRad(parameters.azimuth);

        sun.setFromSphericalCoords(1, phi, theta);

        sky.material.uniforms["sunPosition"].value.copy(sun);
        water.material.uniforms["sunDirection"].value.copy(sun).normalize();

        scene.environment = pmremGenerator.fromScene(sky).texture;
      }

      updateSun();

      //

      const geometry = new THREE.BoxGeometry(30, 30, 30);
      const material = new THREE.MeshStandardMaterial({ roughness: 0 });

      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      //

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.maxPolarAngle = Math.PI * 0.495;
      controls.target.set(0, 10, 0);
      controls.minDistance = 40.0;
      controls.maxDistance = 200.0;
      controls.update();

      //

      stats = new Stats();
      container.appendChild(stats.dom);

      // GUI

      const gui = new dat.GUI();

      const folderSky = gui.addFolder("Sky");
      folderSky.add(parameters, "elevation", 0, 90, 0.1).onChange(updateSun);
      folderSky.add(parameters, "azimuth", -180, 180, 0.1).onChange(updateSun);
      folderSky.open();

      const waterUniforms = water.material.uniforms;

      const folderWater = gui.addFolder("Water");
      folderWater
        .add(waterUniforms.distortionScale, "value", 0, 8, 0.1)
        .name("distortionScale");
      folderWater.add(waterUniforms.size, "value", 0.1, 10, 0.1).name("size");
      folderWater.open();

      //

      window.addEventListener("resize", onWindowResize);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      render();
      stats.update();
    }

    function render() {
      const time = performance.now() * 0.001;

      mesh.position.y = Math.sin(time) * 20 + 5;
      mesh.rotation.x = time * 0.5;
      mesh.rotation.z = time * 0.51;

      water.material.uniforms["time"].value += 1.0 / 60.0;

      renderer.render(scene, camera);
    }
  </script> -->

  <script>
    // 用于模拟的纹理宽度
    const WIDTH = 128;

    // 系统单位中的水量
    const BOUNDS = 512; // 平面尺寸
    const BOUNDS_HALF = BOUNDS * 0.5;

    let container, stats;
    let camera, scene, renderer;
    let mouseMoved = false;
    const mouseCoords = new THREE.Vector2(); // 二维向量
    const raycaster = new THREE.Raycaster(); // 光线投射 用于进行鼠标拾取

    let waterMesh;
    let meshRay;
    let gpuCompute;
    let heightmapVariable;
    let waterUniforms;
    let smoothShader;
    let readWaterLevelShader;
    let readWaterLevelRenderTarget;
    let readWaterLevelImage;
    const waterNormal = new THREE.Vector3(); // 三维向量

    const NUM_SPHERES = 5;
    const spheres = [];
    let spheresEnabled = true;

    const simplex = new THREE.SimplexNoise(); // Simplex 噪声

    init();
    animate();

    function init() {
      container = document.createElement("div"); // 画布盒子
      document.body.appendChild(container);

      camera = new THREE.PerspectiveCamera(
        90,
        window.innerWidth / window.innerHeight,
        1,
        3000
      ); // 透视相机
      camera.position.set(0, 400, 0);
      camera.lookAt(0, 0, 0);

      scene = new THREE.Scene(); // 场景

      const sun = new THREE.DirectionalLight(0xffffff, 1.0); // 平行光
      sun.position.set(0, 400, 0);
      scene.add(sun);

      renderer = new THREE.WebGLRenderer(); // 渲染器
      renderer.setPixelRatio(window.devicePixelRatio); // 设置设备像素比
      renderer.setSize(window.innerWidth, window.innerHeight); // 大小调整
      container.appendChild(renderer.domElement);

      stats = new Stats(); // 性能监视器
      container.appendChild(stats.dom);

      container.style.touchAction = "none";
      container.addEventListener("pointermove", onPointerMove); // 指针移动事件

      document.addEventListener("keydown", function (event) {
        // W Pressed: Toggle wireframe
        if (event.keyCode === 87) {
          waterMesh.material.wireframe = !waterMesh.material.wireframe;
          waterMesh.material.needsUpdate = true;
        }
      });

      window.addEventListener("resize", onWindowResize);

      const gui = new dat.GUI(); // 用于在 JavaScript 中更改变量的轻量级图形用户界面

      const effectController = {
        mouseSize: 20.0,
        viscosity: 0.98,
        spheresEnabled: spheresEnabled,
      };

      const valuesChanger = function () {
        heightmapVariable.material.uniforms["mouseSize"].value =
          effectController.mouseSize;
        heightmapVariable.material.uniforms["viscosityConstant"].value =
          effectController.viscosity;
        spheresEnabled = effectController.spheresEnabled;
        for (let i = 0; i < NUM_SPHERES; i++) {
          if (spheres[i]) {
            spheres[i].visible = spheresEnabled;
          }
        }
      };

      gui
        .add(effectController, "mouseSize", 1.0, 100.0, 1.0)
        .onChange(valuesChanger);
      gui
        .add(effectController, "viscosity", 0.9, 0.999, 0.001)
        .onChange(valuesChanger);
      gui
        .add(effectController, "spheresEnabled", 0, 1, 1)
        .onChange(valuesChanger);
      const buttonSmooth = {
        smoothWater: function () {
          smoothWater();
        },
      };
      gui.add(buttonSmooth, "smoothWater");

      initWater();

      // createSpheres();

      // valuesChanger();
    }

    function initWater() {
      const materialColor = 0x0040c0; // 材质颜色

      const geometry = new THREE.PlaneGeometry(
        BOUNDS,
        BOUNDS,
        WIDTH - 1,
        WIDTH - 1
      ); // 平面几何体

      console.log(new THREE.TextureLoader().load("mv.jpg"))
      // var uniforms = {
      //   texture1: { value: new THREE.TextureLoader().load("mv.jpg") },
      // };
      // //设置平铺方式
      // uniforms.texture1.value.warpS = uniforms.texture1.value.warpT = THREE.RepeatWrapping;
      // material：制作 THREE.MeshPhongMaterial 的 THREE.ShaderMaterial 克隆，带有自定义的顶点着色器
      const material = new THREE.ShaderMaterial({
        // 着色器材质
        uniforms: THREE.UniformsUtils.merge([
          // Uniform工具. 支持uniform变量的合并和克隆
          THREE.ShaderLib["phong"].uniforms, // three.js的WebGL着色器库
          {
            heightmap: { value: null }
          },
        ]),
        // uniforms,
        // vertexShader: document.getElementById("vertexShader").textContent,
        // fragmentShader: document.getElementById("fragmentShader").textContent,
        // side: THREE.DoubleSide,
        vertexShader: document.getElementById("waterVertexShader").textContent,
        fragmentShader: THREE.ShaderChunk["meshphong_frag"], // WebGL着色器库的着色器片段
      });

      material.lights = true;

      // 来自 THREE.MeshPhongMaterial 的材料属性
      material.color = new THREE.Color(materialColor);
      material.specular = new THREE.Color(0x111111);
      material.shininess = 50;

      // 使用材质值设置uniforms
      material.uniforms["diffuse"].value = material.color;
      material.uniforms["specular"].value = material.specular;
      material.uniforms["shininess"].value = Math.max(material.shininess, 1e-4);
      material.uniforms["opacity"].value = material.opacity;

      // Defines
      material.defines.WIDTH = WIDTH.toFixed(1);
      material.defines.BOUNDS = BOUNDS.toFixed(1);

      waterUniforms = material.uniforms;

      waterMesh = new THREE.Mesh(geometry, material);
      waterMesh.rotation.x = -Math.PI / 2;
      waterMesh.matrixAutoUpdate = false;
      waterMesh.updateMatrix();

      scene.add(waterMesh);

      // THREE.Mesh 只用于鼠标光线投射
      const geometryRay = new THREE.PlaneGeometry(BOUNDS, BOUNDS, 1, 1);
      meshRay = new THREE.Mesh(
        geometryRay,
        new THREE.MeshBasicMaterial({ color: 0xffffff, visible: false })
      );
      meshRay.rotation.x = -Math.PI / 2;
      meshRay.matrixAutoUpdate = false;
      meshRay.updateMatrix();
      scene.add(meshRay);

      // 创建 GPU 计算类并进行设置

      gpuCompute = new THREE.GPUComputationRenderer(WIDTH, WIDTH, renderer);

      if (isSafari()) {
        gpuCompute.setDataType(THREE.HalfFloatType);
      }

      const heightmap0 = gpuCompute.createTexture();

      fillTexture(heightmap0);

      heightmapVariable = gpuCompute.addVariable(
        "heightmap",
        document.getElementById("heightmapFragmentShader").textContent,
        heightmap0
      );

      gpuCompute.setVariableDependencies(heightmapVariable, [
        heightmapVariable,
      ]);

      heightmapVariable.material.uniforms["mousePos"] = {
        value: new THREE.Vector2(10000, 10000),
      };
      heightmapVariable.material.uniforms["mouseSize"] = { value: 20.0 };
      heightmapVariable.material.uniforms["viscosityConstant"] = {
        value: 0.98,
      };
      heightmapVariable.material.uniforms["heightCompensation"] = { value: 0 };
      heightmapVariable.material.defines.BOUNDS = BOUNDS.toFixed(1);

      const error = gpuCompute.init();
      if (error !== null) {
        console.error(error);
      }

      // 创建计算着色器以平滑水面和速度
      smoothShader = gpuCompute.createShaderMaterial(
        document.getElementById("smoothFragmentShader").textContent,
        { smoothTexture: { value: null } }
      );

      // 创建计算着色器以读取水位
      readWaterLevelShader = gpuCompute.createShaderMaterial(
        document.getElementById("readWaterLevelFragmentShader").textContent,
        {
          point1: { value: new THREE.Vector2() },
          levelTexture: { value: null },
        }
      );
      readWaterLevelShader.defines.WIDTH = WIDTH.toFixed(1);
      readWaterLevelShader.defines.BOUNDS = BOUNDS.toFixed(1);

      // 创建一个 4x1 像素图像和一个渲染目标（Uint8，4 个通道，每通道 1 个字节）以读取水的高度和方向
      readWaterLevelImage = new Uint8Array(4 * 1 * 4);

      readWaterLevelRenderTarget = new THREE.WebGLRenderTarget(4, 1, {
        wrapS: THREE.ClampToEdgeWrapping,
        wrapT: THREE.ClampToEdgeWrapping,
        minFilter: THREE.NearestFilter,
        magFilter: THREE.NearestFilter,
        format: THREE.RGBAFormat,
        type: THREE.UnsignedByteType,
        depthBuffer: false,
      });
    }

    function isSafari() {
      return (
        !!navigator.userAgent.match(/Safari/i) &&
        !navigator.userAgent.match(/Chrome/i)
      );
    }

    function fillTexture(texture) {
      // 填充纹理
      const waterMaxHeight = 10; // 水最大高度

      function noise(x, y) {
        // 噪音
        let multR = waterMaxHeight;
        let mult = 0.025;
        let r = 0;
        for (let i = 0; i < 15; i++) {
          r += multR * simplex.noise(x * mult, y * mult);
          multR *= 0.53 + 0.025 * i;
          mult *= 1.25;
        }

        return r;
      }

      const pixels = texture.image.data;

      let p = 0;
      for (let j = 0; j < WIDTH; j++) {
        for (let i = 0; i < WIDTH; i++) {
          const x = (i * 128) / WIDTH;
          const y = (j * 128) / WIDTH;

          pixels[p + 0] = noise(x, y);
          pixels[p + 1] = pixels[p + 0];
          pixels[p + 2] = 0;
          pixels[p + 3] = 1;

          p += 4;
        }
      }
    }

    function smoothWater() {
      // 光滑的水
      const currentRenderTarget =
        gpuCompute.getCurrentRenderTarget(heightmapVariable); // 获取当前渲染目标
      const alternateRenderTarget =
        gpuCompute.getAlternateRenderTarget(heightmapVariable); // 获取替代渲染目标

      for (let i = 0; i < 10; i++) {
        smoothShader.uniforms["smoothTexture"].value =
          currentRenderTarget.texture;
        gpuCompute.doRenderTarget(smoothShader, alternateRenderTarget); // 渲染目标

        smoothShader.uniforms["smoothTexture"].value =
          alternateRenderTarget.texture;
        gpuCompute.doRenderTarget(smoothShader, currentRenderTarget); // 渲染目标
      }
    }

    function createSpheres() {
      // 创建球体
      const sphereTemplate = new THREE.Mesh(
        new THREE.SphereGeometry(4, 24, 12),
        new THREE.MeshPhongMaterial({ color: 0xffff00 })
      );

      for (let i = 0; i < NUM_SPHERES; i++) {
        let sphere = sphereTemplate;
        if (i < NUM_SPHERES - 1) {
          sphere = sphereTemplate.clone();
        }

        sphere.position.x = (Math.random() - 0.5) * BOUNDS * 0.7;
        sphere.position.z = (Math.random() - 0.5) * BOUNDS * 0.7;

        sphere.userData.velocity = new THREE.Vector3();

        scene.add(sphere);

        spheres[i] = sphere;
      }
    }

    function sphereDynamics() {
      // 领域动力学
      const currentRenderTarget =
        gpuCompute.getCurrentRenderTarget(heightmapVariable); // 获取当前渲染目标

      readWaterLevelShader.uniforms["levelTexture"].value =
        currentRenderTarget.texture;

      for (let i = 0; i < NUM_SPHERES; i++) {
        const sphere = spheres[i];

        if (sphere) {
          // 读取水位和方向
          const u = (0.5 * sphere.position.x) / BOUNDS_HALF + 0.5;
          const v = 1 - ((0.5 * sphere.position.z) / BOUNDS_HALF + 0.5);
          readWaterLevelShader.uniforms["point1"].value.set(u, v);
          gpuCompute.doRenderTarget(
            readWaterLevelShader,
            readWaterLevelRenderTarget
          );

          renderer.readRenderTargetPixels(
            readWaterLevelRenderTarget,
            0,
            0,
            4,
            1,
            readWaterLevelImage
          ); // 读取渲染目标像素
          const pixels = new Float32Array(readWaterLevelImage.buffer);

          // 获取方向
          waterNormal.set(pixels[1], 0, -pixels[2]);

          const pos = sphere.position;

          // 设置高度
          pos.y = pixels[0];

          // 移动球体
          waterNormal.multiplyScalar(0.1);
          sphere.userData.velocity.add(waterNormal);
          sphere.userData.velocity.multiplyScalar(0.998);
          pos.add(sphere.userData.velocity);

          if (pos.x < -BOUNDS_HALF) {
            pos.x = -BOUNDS_HALF + 0.001;
            sphere.userData.velocity.x *= -0.3;
          } else if (pos.x > BOUNDS_HALF) {
            pos.x = BOUNDS_HALF - 0.001;
            sphere.userData.velocity.x *= -0.3;
          }

          if (pos.z < -BOUNDS_HALF) {
            pos.z = -BOUNDS_HALF + 0.001;
            sphere.userData.velocity.z *= -0.3;
          } else if (pos.z > BOUNDS_HALF) {
            pos.z = BOUNDS_HALF - 0.001;
            sphere.userData.velocity.z *= -0.3;
          }
        }
      }
    }

    function onWindowResize() {
      // 重置
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function setMouseCoords(x, y) {
      // 设置鼠标坐标
      mouseCoords.set(
        (x / renderer.domElement.clientWidth) * 2 - 1,
        -(y / renderer.domElement.clientHeight) * 2 + 1
      );
      mouseMoved = true;
    }

    function onPointerMove(event) {
      // 指针移动
      if (event.isPrimary === false) return;

      setMouseCoords(event.clientX, event.clientY);
    }

    function animate() {
      requestAnimationFrame(animate);

      render();
      stats.update();
    }

    function render() {
      // 设置uniforms：鼠标交互
      const uniforms = heightmapVariable.material.uniforms;
      if (mouseMoved) {
        raycaster.setFromCamera(mouseCoords, camera);

        const intersects = raycaster.intersectObject(meshRay);

        if (intersects.length > 0) {
          const point = intersects[0].point;
          uniforms["mousePos"].value.set(point.x, point.z);
        } else {
          uniforms["mousePos"].value.set(10000, 10000);
        }

        mouseMoved = false;
      } else {
        uniforms["mousePos"].value.set(10000, 10000);
      }

      // GPU计算
      gpuCompute.compute();

      if (spheresEnabled) {
        sphereDynamics();
      }

      // 以自定义uniforms获取计算输出
      waterUniforms["heightmap"].value =
        gpuCompute.getCurrentRenderTarget(heightmapVariable).texture;

      // Render
      renderer.render(scene, camera);
    }
  </script>

  <!-- self -->
  <!-- <script>
    var container = document.querySelector("#container");

    var stats = new Stats(); // 性能监视器
    container.appendChild(stats.dom);

    var scene = new THREE.Scene();

    var camera = new THREE.PerspectiveCamera(
      45,
      window.innerWidth / window.innerHeight,
      0.1,
      10000
    );
    camera.position.set(0, 0, 10);
    camera.lookAt(scene.position);

    var renderer = new THREE.WebGLRenderer({ antialias: true });
    // renderer.setClearColor(0xffffff);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    var textureLoader = new THREE.TextureLoader();

    //配置shaderMaterial中的uniforms属性
    var uniforms = {
      texture1: { value: textureLoader.load("mv.jpg") },
    };
    //设置平铺方式
    uniforms.texture1.value.warpS = uniforms.texture1.value.warpT =
      THREE.RepeatWrapping;

    var planeGeometry = new THREE.PlaneGeometry(3, 3);
    var planeMaterial = new THREE.ShaderMaterial({
      uniforms: uniforms,
      vertexShader: document.getElementById("vertexShader").textContent,
      fragmentShader: document.getElementById("fragmentShader").textContent,
      side: THREE.DoubleSide,
    });
    var plane = new THREE.Mesh(planeGeometry, planeMaterial);
    scene.add(plane);

    var orbitControls = new THREE.OrbitControls(camera, renderer.domElement);

    function render() {
      stats.update();
      requestAnimationFrame(render);
      renderer.render(scene, camera);
    }

    render();
  </script> -->
</html>
